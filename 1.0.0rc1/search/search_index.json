{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Repid Repid framework: simple to use, fast to run and extensible to adopt job scheduler. Example Here is how the easiest example of producer-consumer application can look like. Producer: import asyncio from repid import Connection , Job , RabbitMessageBroker , Repid app = Repid ( Connection ( RabbitMessageBroker ( \"amqp://user:password@localhost:5672\" ))) async def main () -> None : async with app . magic (): await Job ( name = \"awesome_job\" ) . enqueue () asyncio . run ( main ()) Consumer: import asyncio from repid import Connection , RabbitMessageBroker , Repid , Router , Worker app = Repid ( Connection ( RabbitMessageBroker ( \"amqp://user:password@localhost:5672\" ))) router = Router () @router . actor async def awesome_job () -> None : print ( \"Hello async jobs!\" ) await asyncio . sleep ( 1.0 ) async def main () -> None : async with app . magic (): await Worker ( routers = [ router ]) . run () asyncio . run ( main ()) Install Repid supports Python versions 3.8 and up and is installable via pip . pip install repid There are also a couple of additional dependencies you may want to install, depending on your use case, e.g. pip install repid [ amqp, redis, cron ] Why repid? Asyncio Repid is built around asyncio . It means it's pretty fast. And you don't have to worry that it will slow down your other asyncio-driven code. Ease of integration There is an abstraction layer on top of other queue solutions. It means that even if repid doesn't provide some broker out of the box, you will be able to write your own. Built with microservices in mind Your producer and consumer can be running in different containers, repid will handle it just fine. Can be used with other languages Repid uses json (de-)serialization by default, which makes integration with other languages as easy as possible. You're also able to easily override default (de-)serialization behavior thanks to PEP 544 Protocols. Integrated scheduling Repid has its own scheduling mechanisms. You can delay job execution until some date or even execute it every once in a while. No need for extra dependencies! Inspiration Repid is inspired by dramatiq and arq . License Repid is distributed under the terms of the MIT license. Please see License.md for more information. Repid's logo is distributed under the terms of the CC BY-NC 4.0 license. It is originally created by ari_the_crow_ .","title":"Home"},{"location":"#repid","text":"Repid framework: simple to use, fast to run and extensible to adopt job scheduler.","title":"Repid"},{"location":"#example","text":"Here is how the easiest example of producer-consumer application can look like. Producer: import asyncio from repid import Connection , Job , RabbitMessageBroker , Repid app = Repid ( Connection ( RabbitMessageBroker ( \"amqp://user:password@localhost:5672\" ))) async def main () -> None : async with app . magic (): await Job ( name = \"awesome_job\" ) . enqueue () asyncio . run ( main ()) Consumer: import asyncio from repid import Connection , RabbitMessageBroker , Repid , Router , Worker app = Repid ( Connection ( RabbitMessageBroker ( \"amqp://user:password@localhost:5672\" ))) router = Router () @router . actor async def awesome_job () -> None : print ( \"Hello async jobs!\" ) await asyncio . sleep ( 1.0 ) async def main () -> None : async with app . magic (): await Worker ( routers = [ router ]) . run () asyncio . run ( main ())","title":"Example"},{"location":"#install","text":"Repid supports Python versions 3.8 and up and is installable via pip . pip install repid There are also a couple of additional dependencies you may want to install, depending on your use case, e.g. pip install repid [ amqp, redis, cron ]","title":"Install"},{"location":"#why-repid","text":"","title":"Why repid?"},{"location":"#asyncio","text":"Repid is built around asyncio . It means it's pretty fast. And you don't have to worry that it will slow down your other asyncio-driven code.","title":"Asyncio"},{"location":"#ease-of-integration","text":"There is an abstraction layer on top of other queue solutions. It means that even if repid doesn't provide some broker out of the box, you will be able to write your own.","title":"Ease of integration"},{"location":"#built-with-microservices-in-mind","text":"Your producer and consumer can be running in different containers, repid will handle it just fine.","title":"Built with microservices in mind"},{"location":"#can-be-used-with-other-languages","text":"Repid uses json (de-)serialization by default, which makes integration with other languages as easy as possible. You're also able to easily override default (de-)serialization behavior thanks to PEP 544 Protocols.","title":"Can be used with other languages"},{"location":"#integrated-scheduling","text":"Repid has its own scheduling mechanisms. You can delay job execution until some date or even execute it every once in a while. No need for extra dependencies!","title":"Integrated scheduling"},{"location":"#inspiration","text":"Repid is inspired by dramatiq and arq .","title":"Inspiration"},{"location":"#license","text":"Repid is distributed under the terms of the MIT license. Please see License.md for more information. Repid's logo is distributed under the terms of the CC BY-NC 4.0 license. It is originally created by ari_the_crow_ .","title":"License"},{"location":"quickstart_guide/","text":"Quickstart Guide Before we start To follow this guide you will need a virtual environment with repid installed. We will use dummy brokers, but feel free to exchange those for any other ones - it should just work . Consumer Let's start by creating a simple pseudo-async function that counts length of a string: import asyncio async def string_length ( the_string : str ) -> int : await asyncio . sleep ( 1 ) print ( the_string ) return len ( the_string ) Now, we have to create a router for repid to know, that string_length actor exists. import asyncio import repid router = repid . Router () @router . actor async def string_length ( the_string : str ) -> int : await asyncio . sleep ( 1 ) print ( the_string ) return len ( the_string ) Aaand let's finish our application with specifying connection and creating a worker. import asyncio import repid app = repid . Repid ( repid . Connection ( repid . DummyMessageBroker ())) # (1) router = repid . Router () @router . actor async def string_length ( the_string : str ) -> int : await asyncio . sleep ( 1 ) print ( the_string ) return len ( the_string ) async def main () -> None : # (2) async with app . magic (): # (3) worker = repid . Worker ( routers = [ router ]) # (4) await worker . run () # (5) if __name__ == \"__main__\" : asyncio . run ( main ()) Create a repid app with the dummy message broker. The main function, which will execute our async code. Inside of this context manager every object will be provided with the connection that is attached to the repid app which we've created. Create an instance of a worker. Don't forget to specify our router! Run the worker until it receives a SIGINT ( Ctrl + C ) or a SIGTERM . Producer Let's enqueue a job! example.py import asyncio import repid app = repid . Repid ( repid . Connection ( repid . DummyMessageBroker ())) router = repid . Router () @router . actor async def string_length ( the_string : str ) -> int : await asyncio . sleep ( 1 ) print ( the_string ) return len ( the_string ) async def main () -> None : async with app . magic (): hello_job = repid . Job ( \"string_length\" , # (1) args = dict ( the_string = \"Hello world!\" ), # (2) ) await hello_job . queue . declare () # (3) await hello_job . enqueue () worker = repid . Worker ( routers = [ router ]) await worker . run () if __name__ == \"__main__\" : asyncio . run ( main ()) Name of the job will be used to route it to the similarly named actor. Using dictionary to map arguments' names to values. The dictionary will be encoded with orjson by default. You only need to declare a queue once. Ideally you would do that on application startup. This will enqueue a job to the default queue, which than worker will consume & route to the string_length function with argument the_string set to \"Hello world!\" . After running the script, you should receive: $ python example.py Hello world!","title":"Quickstart Guide"},{"location":"quickstart_guide/#quickstart-guide","text":"","title":"Quickstart Guide"},{"location":"quickstart_guide/#before-we-start","text":"To follow this guide you will need a virtual environment with repid installed. We will use dummy brokers, but feel free to exchange those for any other ones - it should just work .","title":"Before we start"},{"location":"quickstart_guide/#consumer","text":"Let's start by creating a simple pseudo-async function that counts length of a string: import asyncio async def string_length ( the_string : str ) -> int : await asyncio . sleep ( 1 ) print ( the_string ) return len ( the_string ) Now, we have to create a router for repid to know, that string_length actor exists. import asyncio import repid router = repid . Router () @router . actor async def string_length ( the_string : str ) -> int : await asyncio . sleep ( 1 ) print ( the_string ) return len ( the_string ) Aaand let's finish our application with specifying connection and creating a worker. import asyncio import repid app = repid . Repid ( repid . Connection ( repid . DummyMessageBroker ())) # (1) router = repid . Router () @router . actor async def string_length ( the_string : str ) -> int : await asyncio . sleep ( 1 ) print ( the_string ) return len ( the_string ) async def main () -> None : # (2) async with app . magic (): # (3) worker = repid . Worker ( routers = [ router ]) # (4) await worker . run () # (5) if __name__ == \"__main__\" : asyncio . run ( main ()) Create a repid app with the dummy message broker. The main function, which will execute our async code. Inside of this context manager every object will be provided with the connection that is attached to the repid app which we've created. Create an instance of a worker. Don't forget to specify our router! Run the worker until it receives a SIGINT ( Ctrl + C ) or a SIGTERM .","title":"Consumer"},{"location":"quickstart_guide/#producer","text":"Let's enqueue a job! example.py import asyncio import repid app = repid . Repid ( repid . Connection ( repid . DummyMessageBroker ())) router = repid . Router () @router . actor async def string_length ( the_string : str ) -> int : await asyncio . sleep ( 1 ) print ( the_string ) return len ( the_string ) async def main () -> None : async with app . magic (): hello_job = repid . Job ( \"string_length\" , # (1) args = dict ( the_string = \"Hello world!\" ), # (2) ) await hello_job . queue . declare () # (3) await hello_job . enqueue () worker = repid . Worker ( routers = [ router ]) await worker . run () if __name__ == \"__main__\" : asyncio . run ( main ()) Name of the job will be used to route it to the similarly named actor. Using dictionary to map arguments' names to values. The dictionary will be encoded with orjson by default. You only need to declare a queue once. Ideally you would do that on application startup. This will enqueue a job to the default queue, which than worker will consume & route to the string_length function with argument the_string set to \"Hello world!\" . After running the script, you should receive: $ python example.py Hello world!","title":"Producer"}]}