# generated by datamodel-codegen:
#   filename:  3.0.0-without-$id.json
#   timestamp: 2024-12-18T11:23:24+00:00

from __future__ import annotations

from collections.abc import Mapping, Sequence
from typing import Any, Literal, TypedDict

from typing_extensions import NotRequired

from .extensions_linkedin_0 import field_1 as field_1_1
from .extensions_x_0 import field_1

SpecificationExtension = Any


class Contact(TypedDict):
    name: NotRequired[str]
    url: NotRequired[str]
    email: NotRequired[str]


class License(TypedDict):
    name: str
    url: NotRequired[str]


ReferenceObject = str


class ExternalDocs(TypedDict):
    description: NotRequired[str]
    url: str


class ServerVariable(TypedDict):
    enum: NotRequired[Sequence[str]]
    default: NotRequired[str]
    description: NotRequired[str]
    examples: NotRequired[Sequence[str]]


class UserPassword(TypedDict):
    type: Literal["userPassword"]
    description: NotRequired[str]


ApiKey = TypedDict(
    "ApiKey",
    {
        "type": Literal["apiKey"],
        "in": Literal["user", "password"],
        "description": NotRequired[str],
    },
)


class X509(TypedDict):
    type: Literal["X509"]
    description: NotRequired[str]


class SymmetricEncryption(TypedDict):
    type: Literal["symmetricEncryption"]
    description: NotRequired[str]


class AsymmetricEncryption(TypedDict):
    type: Literal["asymmetricEncryption"]
    description: NotRequired[str]


class NonBearerHTTPSecurityScheme(TypedDict):
    scheme: str
    description: NotRequired[str]
    type: Literal["http"]


class BearerHTTPSecurityScheme(TypedDict):
    scheme: Literal["bearer"]
    bearer_format: NotRequired[str]
    type: Literal["http"]
    description: NotRequired[str]


APIKeyHTTPSecurityScheme = TypedDict(
    "APIKeyHTTPSecurityScheme",
    {
        "type": Literal["httpApiKey"],
        "name": str,
        "in": Literal["header", "query", "cookie"],
        "description": NotRequired[str],
    },
)


Oauth2Scopes = Mapping[str, str] | None


class OpenIdConnect(TypedDict):
    type: Literal["openIdConnect"]
    description: NotRequired[str]
    open_id_connect_url: str
    scopes: NotRequired[Sequence[str]]


class SaslPlainSecurityScheme(TypedDict):
    type: Literal["plain"]
    description: NotRequired[str]


class SaslScramSecurityScheme(TypedDict):
    type: Literal["scramSha256", "scramSha512"]
    description: NotRequired[str]


class SaslGssapiSecurityScheme(TypedDict):
    type: Literal["gssapi"]
    description: NotRequired[str]


class Mqtt(TypedDict):
    binding_version: NotRequired[Literal["0.2.0"]]


class Kafka(TypedDict):
    binding_version: NotRequired[Literal["0.5.0", "0.4.0", "0.3.0"]]


class Jms(TypedDict):
    binding_version: NotRequired[Literal["0.0.1"]]


class Ibmmq(TypedDict):
    binding_version: NotRequired[Literal["0.1.0"]]


class Solace(TypedDict):
    binding_version: NotRequired[Literal["0.4.0", "0.3.0", "0.2.0"]]


class Pulsar(TypedDict):
    binding_version: NotRequired[Literal["0.1.0"]]


class ServerBindingsObject(TypedDict):
    http: NotRequired[Any]
    ws: NotRequired[Any]
    amqp: NotRequired[Any]
    amqp1: NotRequired[Any]
    mqtt: NotRequired[Mqtt]
    kafka: NotRequired[Kafka]
    anypointmq: NotRequired[Any]
    nats: NotRequired[Any]
    jms: NotRequired[Jms]
    sns: NotRequired[Any]
    sqs: NotRequired[Any]
    stomp: NotRequired[Any]
    redis: NotRequired[Any]
    ibmmq: NotRequired[Ibmmq]
    solace: NotRequired[Solace]
    googlepubsub: NotRequired[Any]
    pulsar: NotRequired[Pulsar]


AnySchema = Any


class MultiFormatSchema(TypedDict):
    pass


class CorrelationId(TypedDict):
    description: NotRequired[str]
    location: str


class MessageExampleObject1(TypedDict):
    name: NotRequired[str]
    summary: NotRequired[str]
    headers: NotRequired[Mapping[str, Any]]
    payload: Any


class MessageExampleObject2(TypedDict):
    name: NotRequired[str]
    summary: NotRequired[str]
    headers: Mapping[str, Any]
    payload: NotRequired[Any]


MessageExampleObject = MessageExampleObject1 | MessageExampleObject2


class Http(TypedDict):
    binding_version: NotRequired[Literal["0.2.0", "0.3.0"]]


class Amqp(TypedDict):
    binding_version: NotRequired[Literal["0.3.0"]]


class Anypointmq(TypedDict):
    binding_version: NotRequired[Literal["0.0.1"]]


class Googlepubsub(TypedDict):
    binding_version: NotRequired[Literal["0.2.0"]]


class MessageBindingsObject(TypedDict):
    http: NotRequired[Http]
    ws: NotRequired[Any]
    amqp: NotRequired[Amqp]
    amqp1: NotRequired[Any]
    mqtt: NotRequired[Mqtt]
    kafka: NotRequired[Kafka]
    anypointmq: NotRequired[Anypointmq]
    nats: NotRequired[Any]
    jms: NotRequired[Jms]
    sns: NotRequired[Any]
    sqs: NotRequired[Any]
    stomp: NotRequired[Any]
    redis: NotRequired[Any]
    ibmmq: NotRequired[Ibmmq]
    solace: NotRequired[Any]
    googlepubsub: NotRequired[Googlepubsub]


class Parameter(TypedDict):
    description: NotRequired[str]
    enum: NotRequired[Sequence[str]]
    default: NotRequired[str]
    examples: NotRequired[Sequence[str]]
    location: NotRequired[str]


class Ws(TypedDict):
    binding_version: NotRequired[Literal["0.1.0"]]


class Sns(TypedDict):
    binding_version: NotRequired[Literal["0.1.0"]]


class Sqs(TypedDict):
    binding_version: NotRequired[Literal["0.2.0"]]


class ChannelBindingsObject(TypedDict):
    http: NotRequired[Any]
    ws: NotRequired[Ws]
    amqp: NotRequired[Amqp]
    amqp1: NotRequired[Any]
    mqtt: NotRequired[Any]
    kafka: NotRequired[Kafka]
    anypointmq: NotRequired[Anypointmq]
    nats: NotRequired[Any]
    jms: NotRequired[Jms]
    sns: NotRequired[Sns]
    sqs: NotRequired[Sqs]
    stomp: NotRequired[Any]
    redis: NotRequired[Any]
    ibmmq: NotRequired[Ibmmq]
    solace: NotRequired[Any]
    googlepubsub: NotRequired[Googlepubsub]
    pulsar: NotRequired[Pulsar]


class OperationReplyAddress(TypedDict):
    location: str
    description: NotRequired[str]


class Nats(TypedDict):
    binding_version: NotRequired[Literal["0.1.0"]]


class OperationBindingsObject(TypedDict):
    http: NotRequired[Http]
    ws: NotRequired[Any]
    amqp: NotRequired[Amqp]
    amqp1: NotRequired[Any]
    mqtt: NotRequired[Mqtt]
    kafka: NotRequired[Kafka]
    anypointmq: NotRequired[Any]
    nats: NotRequired[Nats]
    jms: NotRequired[Any]
    sns: NotRequired[Sns]
    sqs: NotRequired[Sqs]
    stomp: NotRequired[Any]
    redis: NotRequired[Any]
    ibmmq: NotRequired[Any]
    solace: NotRequired[Solace]
    googlepubsub: NotRequired[Any]


class Property(TypedDict):
    name: str
    value: str | bool | float | None


class Ordering(TypedDict):
    type: Literal["standard", "FIFO"]
    content_based_deduplication: NotRequired[bool]


class DeliveryPolicy(TypedDict):
    min_delay_target: NotRequired[int]
    max_delay_target: NotRequired[int]
    num_retries: NotRequired[int]
    num_no_delay_retries: NotRequired[int]
    num_min_delay_retries: NotRequired[int]
    num_max_delay_retries: NotRequired[int]
    backoff_function: NotRequired[Literal["arithmetic", "exponential", "geometric", "linear"]]
    max_receives_per_second: NotRequired[int]


class Identifier(TypedDict):
    url: NotRequired[str]
    email: NotRequired[str]
    phone: NotRequired[str]
    arn: NotRequired[str]
    name: NotRequired[str]


NonNegativeInteger = int


class NonNegativeIntegerDefault0(TypedDict):
    pass


SimpleTypes = Literal["array", "boolean", "integer", "null", "number", "object", "string"]


StringArray = Sequence[str]


class Discriminator(TypedDict):
    property_name: str
    mapping: NotRequired[Mapping[str, str]]


class ExternalDocumentation(TypedDict):
    description: NotRequired[str]
    url: str


Reference = Mapping[str, str]


class XML(TypedDict):
    name: NotRequired[str]
    namespace: NotRequired[str]
    prefix: NotRequired[str]
    attribute: NotRequired[bool]
    wrapped: NotRequired[bool]


Description = str


Summary = str


Title = str


class Statement(TypedDict):
    effect: Literal["Allow", "Deny"]
    principal: str | Sequence[str]
    action: str | Sequence[str]


class RedrivePolicy(TypedDict):
    dead_letter_queue: Identifier
    max_receive_count: NotRequired[int]


CustomTypeReference = str


PrimitiveType = Literal["null", "boolean", "int", "long", "float", "double", "bytes", "string"]


class PrimitiveTypeWithMetadata(TypedDict):
    type: PrimitiveType


class IdentifierModel(TypedDict):
    arn: NotRequired[str]
    name: NotRequired[str]


Name = str


Namespace = str


ReferenceModel = TypedDict(
    "ReferenceModel",
    {
        "$ref": ReferenceObject,
    },
)


class Tag(TypedDict):
    name: str
    description: NotRequired[str]
    external_docs: NotRequired[ReferenceModel | ExternalDocs]


InfoExtensions = TypedDict(
    "InfoExtensions",
    {
        "x-x": NotRequired[field_1.Field0Schema],
        "x-linkedin": NotRequired[field_1_1.Field0Schema],
    },
)


ServerVariables = Mapping[str, ReferenceModel | ServerVariable] | None


HTTPSecurityScheme = (
    NonBearerHTTPSecurityScheme | BearerHTTPSecurityScheme | APIKeyHTTPSecurityScheme
)


class Oauth2Flow(TypedDict):
    authorization_url: NotRequired[str]
    token_url: NotRequired[str]
    refresh_url: NotRequired[str]
    available_scopes: NotRequired[Oauth2Scopes]


SaslSecurityScheme = SaslPlainSecurityScheme | SaslScramSecurityScheme | SaslGssapiSecurityScheme


OpenapiSchema30 = TypedDict(
    "OpenapiSchema30",
    {
        "title": NotRequired[str],
        "multipleOf": NotRequired[float],
        "maximum": NotRequired[float],
        "exclusiveMaximum": NotRequired[bool],
        "minimum": NotRequired[float],
        "exclusiveMinimum": NotRequired[bool],
        "maxLength": NotRequired[int],
        "minLength": NotRequired[int],
        "pattern": NotRequired[str],
        "maxItems": NotRequired[int],
        "minItems": NotRequired[int],
        "uniqueItems": NotRequired[bool],
        "maxProperties": NotRequired[int],
        "minProperties": NotRequired[int],
        "required": NotRequired[Sequence[str]],
        "enum": NotRequired[Sequence],
        "type": NotRequired[Literal["array", "boolean", "integer", "number", "object", "string"]],
        "not": NotRequired[OpenapiSchema30 | Reference],
        "allOf": NotRequired[Sequence[OpenapiSchema30 | Reference]],
        "oneOf": NotRequired[Sequence[OpenapiSchema30 | Reference]],
        "anyOf": NotRequired[Sequence[OpenapiSchema30 | Reference]],
        "items": NotRequired[OpenapiSchema30 | Reference],
        "properties": NotRequired[Mapping[str, OpenapiSchema30 | Reference]],
        "additionalProperties": NotRequired[OpenapiSchema30 | Reference | bool],
        "description": NotRequired[str],
        "format": NotRequired[str],
        "default": NotRequired[Any],
        "nullable": NotRequired[bool],
        "discriminator": NotRequired[Discriminator],
        "readOnly": NotRequired[bool],
        "writeOnly": NotRequired[bool],
        "example": NotRequired[Any],
        "externalDocs": NotRequired[ExternalDocumentation],
        "deprecated": NotRequired[bool],
        "xml": NotRequired[XML],
    },
)


class MessageTrait(TypedDict):
    content_type: NotRequired[str]
    headers: NotRequired[AnySchema]
    correlation_id: NotRequired[ReferenceModel | CorrelationId]
    tags: NotRequired[Sequence[ReferenceModel | Tag]]
    summary: NotRequired[str]
    name: NotRequired[str]
    title: NotRequired[str]
    description: NotRequired[str]
    external_docs: NotRequired[ReferenceModel | ExternalDocs]
    deprecated: NotRequired[bool]
    examples: NotRequired[Sequence[MessageExampleObject]]
    bindings: NotRequired[ReferenceModel | MessageBindingsObject]


Parameters = Mapping[str, ReferenceModel | Parameter] | None


class OperationReply(TypedDict):
    address: NotRequired[ReferenceModel | OperationReplyAddress]
    channel: NotRequired[ReferenceModel]
    messages: NotRequired[Sequence[ReferenceModel]]


class Policy(TypedDict):
    statements: Sequence[Statement]


class Consumer(TypedDict):
    protocol: Literal[
        "http", "https", "email", "email-json", "sms", "sqs", "application", "lambda", "firehose"
    ]
    endpoint: Identifier
    filter_policy: NotRequired[Mapping[str, Sequence[str] | str | Mapping[str, Any]]]
    filter_policy_scope: NotRequired[Literal["MessageAttributes", "MessageBody"]]
    raw_message_delivery: bool
    redrive_policy: NotRequired[RedrivePolicy]
    delivery_policy: NotRequired[DeliveryPolicy]
    display_name: NotRequired[str]


ExternalDocsModel = ReferenceModel | ExternalDocs


Tags = Sequence[ReferenceModel | Tag]


class AvroEnum(TypedDict):
    type: NotRequired[str]
    name: Name
    namespace: NotRequired[Namespace]
    doc: NotRequired[str]
    aliases: NotRequired[Sequence[Name]]
    symbols: Sequence[Name]


class AvroFixed(TypedDict):
    type: NotRequired[str]
    name: Name
    namespace: NotRequired[Namespace]
    doc: NotRequired[str]
    aliases: NotRequired[Sequence[Name]]
    size: float


class Info(InfoExtensions):
    title: str
    version: str
    description: NotRequired[str]
    terms_of_service: NotRequired[str]
    contact: NotRequired[Contact]
    license: NotRequired[License]
    tags: NotRequired[Sequence[ReferenceModel | Tag]]
    external_docs: NotRequired[ReferenceModel | ExternalDocs]


class Flows(TypedDict):
    implicit: NotRequired[Oauth2Flow]
    password: NotRequired[Oauth2Flow]
    client_credentials: NotRequired[Oauth2Flow]
    authorization_code: NotRequired[Oauth2Flow]


class Oauth2Flows(TypedDict):
    type: Literal["oauth2"]
    description: NotRequired[str]
    flows: Flows
    scopes: NotRequired[Sequence[str]]


class MessageObject(TypedDict):
    content_type: NotRequired[str]
    headers: NotRequired[AnySchema]
    payload: NotRequired[AnySchema]
    correlation_id: NotRequired[ReferenceModel | CorrelationId]
    tags: NotRequired[Sequence[ReferenceModel | Tag]]
    summary: NotRequired[str]
    name: NotRequired[str]
    title: NotRequired[str]
    description: NotRequired[str]
    external_docs: NotRequired[ReferenceModel | ExternalDocs]
    deprecated: NotRequired[bool]
    examples: NotRequired[Sequence[MessageExampleObject]]
    bindings: NotRequired[ReferenceModel | MessageBindingsObject]
    traits: NotRequired[
        Sequence[
            ReferenceModel
            | MessageTrait
            | Sequence[ReferenceModel | MessageTrait | Mapping[str, Any]]
        ]
    ]


class Queue(TypedDict):
    name: str
    fifo_queue: bool
    deduplication_scope: NotRequired[Literal["queue", "messageGroup"]]
    fifo_throughput_limit: NotRequired[Literal["perQueue", "perMessageGroupId"]]
    delivery_delay: NotRequired[int]
    visibility_timeout: NotRequired[int]
    receive_message_wait_time: NotRequired[int]
    message_retention_period: NotRequired[int]
    redrive_policy: NotRequired[RedrivePolicy]
    policy: NotRequired[Policy]
    tags: NotRequired[Mapping[str, Any]]


QueueModel = TypedDict(
    "QueueModel",
    {
        "$ref": NotRequired[str],
        "name": str,
        "fifoQueue": NotRequired[bool],
        "deduplicationScope": NotRequired[Literal["queue", "messageGroup"]],
        "fifoThroughputLimit": NotRequired[Literal["perQueue", "perMessageGroupId"]],
        "deliveryDelay": NotRequired[int],
        "visibilityTimeout": NotRequired[int],
        "receiveMessageWaitTime": NotRequired[int],
        "messageRetentionPeriod": NotRequired[int],
        "redrivePolicy": NotRequired[RedrivePolicy],
        "policy": NotRequired[Policy],
        "tags": NotRequired[Mapping[str, Any]],
    },
)


SecurityScheme = (
    UserPassword
    | ApiKey
    | X509
    | SymmetricEncryption
    | AsymmetricEncryption
    | HTTPSecurityScheme
    | Oauth2Flows
    | OpenIdConnect
    | SaslSecurityScheme
)


ChannelMessages = Mapping[str, ReferenceModel | MessageObject] | None


SecurityRequirements = Sequence[ReferenceModel | SecurityScheme]


class Channel(TypedDict):
    address: NotRequired[str | None]
    messages: NotRequired[ChannelMessages]
    parameters: NotRequired[Parameters]
    title: NotRequired[str]
    summary: NotRequired[str]
    description: NotRequired[str]
    servers: NotRequired[Sequence[ReferenceModel]]
    tags: NotRequired[Sequence[ReferenceModel | Tag]]
    external_docs: NotRequired[ReferenceModel | ExternalDocs]
    bindings: NotRequired[ReferenceModel | ChannelBindingsObject]


Security = SecurityRequirements


class Server(TypedDict):
    host: str
    pathname: NotRequired[str]
    title: NotRequired[str]
    summary: NotRequired[str]
    description: NotRequired[str]
    protocol: str
    protocol_version: NotRequired[str]
    variables: NotRequired[ServerVariables]
    security: NotRequired[SecurityRequirements]
    tags: NotRequired[Sequence[ReferenceModel | Tag]]
    external_docs: NotRequired[ReferenceModel | ExternalDocs]
    bindings: NotRequired[ReferenceModel | ServerBindingsObject]


Channels = Mapping[str, ReferenceModel | Channel] | None


class OperationTrait(TypedDict):
    title: NotRequired[Title]
    summary: NotRequired[Summary]
    description: NotRequired[Description]
    security: NotRequired[Security]
    tags: NotRequired[Tags]
    external_docs: NotRequired[ExternalDocsModel]
    bindings: NotRequired[ReferenceModel | OperationBindingsObject]


Servers = Mapping[str, ReferenceModel | Server] | None


class Operation(TypedDict):
    action: Literal["send", "receive"]
    channel: ReferenceModel
    messages: NotRequired[Sequence[ReferenceModel]]
    reply: NotRequired[ReferenceModel | OperationReply]
    traits: NotRequired[Sequence[ReferenceModel | OperationTrait]]
    title: NotRequired[str]
    summary: NotRequired[str]
    description: NotRequired[str]
    security: NotRequired[SecurityRequirements]
    tags: NotRequired[Sequence[ReferenceModel | Tag]]
    external_docs: NotRequired[ReferenceModel | ExternalDocs]
    bindings: NotRequired[ReferenceModel | OperationBindingsObject]


class Components(TypedDict):
    schemas: NotRequired[Mapping[str, AnySchema]]
    servers: NotRequired[Mapping[str, ReferenceModel | Server]]
    channels: NotRequired[Mapping[str, ReferenceModel | Channel]]
    server_variables: NotRequired[Mapping[str, ReferenceModel | ServerVariable]]
    operations: NotRequired[Mapping[str, ReferenceModel | Operation]]
    messages: NotRequired[Mapping[str, ReferenceModel | MessageObject]]
    security_schemes: NotRequired[Mapping[str, ReferenceModel | SecurityScheme]]
    parameters: NotRequired[Mapping[str, ReferenceModel | Parameter]]
    correlation_ids: NotRequired[Mapping[str, ReferenceModel | CorrelationId]]
    operation_traits: NotRequired[Mapping[str, ReferenceModel | OperationTrait]]
    message_traits: NotRequired[Mapping[str, ReferenceModel | MessageTrait]]
    replies: NotRequired[Mapping[str, ReferenceModel | OperationReply]]
    reply_addresses: NotRequired[Mapping[str, ReferenceModel | OperationReplyAddress]]
    server_bindings: NotRequired[Mapping[str, ReferenceModel | ServerBindingsObject]]
    channel_bindings: NotRequired[Mapping[str, ReferenceModel | ChannelBindingsObject]]
    operation_bindings: NotRequired[Mapping[str, ReferenceModel | OperationBindingsObject]]
    message_bindings: NotRequired[Mapping[str, ReferenceModel | MessageBindingsObject]]
    tags: NotRequired[Mapping[str, ReferenceModel | Tag]]
    external_docs: NotRequired[Mapping[str, ReferenceModel | ExternalDocs]]


Operations = Mapping[str, ReferenceModel | Operation] | None


class Asyncapi300Schema(TypedDict):
    asyncapi: NotRequired[str]
    id: NotRequired[str]
    info: Info
    servers: NotRequired[Servers]
    default_content_type: NotRequired[str]
    channels: NotRequired[Channels]
    operations: NotRequired[Operations]
    components: NotRequired[Components]


JsonSchemaDraft07Schema = TypedDict(
    "JsonSchemaDraft07Schema",
    {
        "$id": NotRequired[str],
        "$schema": NotRequired[str],
        "$ref": NotRequired[str],
        "$comment": NotRequired[str],
        "title": NotRequired[str],
        "description": NotRequired[str],
        "default": NotRequired[Any],
        "readOnly": NotRequired[bool],
        "writeOnly": NotRequired[bool],
        "examples": NotRequired[Sequence],
        "multipleOf": NotRequired[float],
        "maximum": NotRequired[float],
        "exclusiveMaximum": NotRequired[float],
        "minimum": NotRequired[float],
        "exclusiveMinimum": NotRequired[float],
        "maxLength": NotRequired[NonNegativeInteger],
        "minLength": NotRequired[NonNegativeIntegerDefault0],
        "pattern": NotRequired[str],
        "additionalItems": NotRequired[JsonSchemaDraft07Schema],
        "items": NotRequired[JsonSchemaDraft07Schema | SchemaArray],
        "maxItems": NotRequired[NonNegativeInteger],
        "minItems": NotRequired[NonNegativeIntegerDefault0],
        "uniqueItems": NotRequired[bool],
        "contains": NotRequired[JsonSchemaDraft07Schema],
        "maxProperties": NotRequired[NonNegativeInteger],
        "minProperties": NotRequired[NonNegativeIntegerDefault0],
        "required": NotRequired[StringArray],
        "additionalProperties": NotRequired[JsonSchemaDraft07Schema],
        "definitions": NotRequired[Mapping[str, JsonSchemaDraft07Schema]],
        "properties": NotRequired[Mapping[str, JsonSchemaDraft07Schema]],
        "patternProperties": NotRequired[Mapping[str, JsonSchemaDraft07Schema]],
        "dependencies": NotRequired[Mapping[str, JsonSchemaDraft07Schema | StringArray]],
        "propertyNames": NotRequired[JsonSchemaDraft07Schema],
        "const": NotRequired[Any],
        "enum": NotRequired[Sequence],
        "type": NotRequired[SimpleTypes | Sequence[SimpleTypes]],
        "format": NotRequired[str],
        "contentMediaType": NotRequired[str],
        "contentEncoding": NotRequired[str],
        "if": NotRequired[JsonSchemaDraft07Schema],
        "then": NotRequired[JsonSchemaDraft07Schema],
        "else": NotRequired[JsonSchemaDraft07Schema],
        "allOf": NotRequired[SchemaArray],
        "anyOf": NotRequired[SchemaArray],
        "oneOf": NotRequired[SchemaArray],
        "not": NotRequired[JsonSchemaDraft07Schema],
    },
)


AvroSchemaV1 = AvroSchema


AvroSchema = Types


SchemaArray = Sequence[JsonSchemaDraft07Schema]


Types = (
    PrimitiveType
    | PrimitiveTypeWithMetadata
    | CustomTypeReference
    | AvroRecord
    | AvroEnum
    | AvroArray
    | AvroMap
    | AvroFixed
    | AvroUnion
)


class AvroArray(TypedDict):
    type: NotRequired[str]
    name: NotRequired[Name]
    namespace: NotRequired[Namespace]
    doc: NotRequired[str]
    aliases: NotRequired[Sequence[Name]]
    items: Types


class AvroMap(TypedDict):
    type: NotRequired[str]
    name: NotRequired[Name]
    namespace: NotRequired[Namespace]
    doc: NotRequired[str]
    aliases: NotRequired[Sequence[Name]]
    values: Types


class AvroRecord(TypedDict):
    type: NotRequired[str]
    name: Name
    namespace: NotRequired[Namespace]
    doc: NotRequired[str]
    aliases: NotRequired[Sequence[Name]]
    fields: Sequence[AvroField]


AvroUnion = Sequence[AvroSchema]


class AvroField(TypedDict):
    name: Name
    type: Types
    doc: NotRequired[str]
    default: NotRequired[Any]
    order: NotRequired[Literal["ascending", "descending", "ignore"]]
    aliases: NotRequired[Sequence[Name]]


Schema = TypedDict(
    "Schema",
    {
        "$id": NotRequired[str],
        "$schema": NotRequired[str],
        "$ref": NotRequired[str],
        "$comment": NotRequired[str],
        "title": NotRequired[str],
        "description": NotRequired[str],
        "default": NotRequired[Any],
        "readOnly": NotRequired[bool],
        "writeOnly": NotRequired[bool],
        "examples": NotRequired[Sequence],
        "multipleOf": NotRequired[float],
        "maximum": NotRequired[float],
        "exclusiveMaximum": NotRequired[float],
        "minimum": NotRequired[float],
        "exclusiveMinimum": NotRequired[float],
        "maxLength": NotRequired[NonNegativeInteger],
        "minLength": NotRequired[NonNegativeIntegerDefault0],
        "pattern": NotRequired[str],
        "additionalItems": NotRequired[JsonSchemaDraft07Schema],
        "items": NotRequired[JsonSchemaDraft07Schema | SchemaArray],
        "maxItems": NotRequired[NonNegativeInteger],
        "minItems": NotRequired[NonNegativeIntegerDefault0],
        "uniqueItems": NotRequired[bool],
        "contains": NotRequired[JsonSchemaDraft07Schema],
        "maxProperties": NotRequired[NonNegativeInteger],
        "minProperties": NotRequired[NonNegativeIntegerDefault0],
        "required": NotRequired[StringArray],
        "additionalProperties": NotRequired[JsonSchemaDraft07Schema],
        "definitions": NotRequired[Mapping[str, JsonSchemaDraft07Schema]],
        "properties": NotRequired[Mapping[str, JsonSchemaDraft07Schema]],
        "patternProperties": NotRequired[Mapping[str, JsonSchemaDraft07Schema]],
        "dependencies": NotRequired[Mapping[str, JsonSchemaDraft07Schema | StringArray]],
        "propertyNames": NotRequired[JsonSchemaDraft07Schema],
        "const": NotRequired[Any],
        "enum": NotRequired[Sequence],
        "type": NotRequired[SimpleTypes | Sequence[SimpleTypes]],
        "format": NotRequired[str],
        "contentMediaType": NotRequired[str],
        "contentEncoding": NotRequired[str],
        "if": NotRequired[JsonSchemaDraft07Schema],
        "then": NotRequired[JsonSchemaDraft07Schema],
        "else": NotRequired[JsonSchemaDraft07Schema],
        "allOf": NotRequired[SchemaArray],
        "anyOf": NotRequired[SchemaArray],
        "oneOf": NotRequired[SchemaArray],
        "not": NotRequired[JsonSchemaDraft07Schema],
        "additionalProperties": NotRequired[Schema | bool],
        "items": NotRequired[Schema | Sequence[Schema]],
        "allOf": NotRequired[Sequence[Schema]],
        "oneOf": NotRequired[Sequence[Schema]],
        "anyOf": NotRequired[Sequence[Schema]],
        "not": NotRequired[Schema],
        "properties": NotRequired[Mapping[str, Schema]],
        "patternProperties": NotRequired[Mapping[str, Schema]],
        "propertyNames": NotRequired[Schema],
        "contains": NotRequired[Schema],
        "discriminator": NotRequired[str],
        "externalDocs": NotRequired[ReferenceModel | ExternalDocs],
        "deprecated": NotRequired[bool],
    },
)
